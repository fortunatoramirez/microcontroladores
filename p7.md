## **Pr谩ctica 7: Temporizaci贸n No Bloqueante con `millis()`**

### **Objetivo de la pr谩ctica**

Aprender a controlar la temporizaci贸n de eventos sin utilizar la funci贸n `delay()`, implementando un sistema de parpadeo de LED basado en `millis()`. Se desarrollar谩 la habilidad de manejar **tareas concurrentes** sin bloquear el flujo del programa.

---

### **1. Introducci贸n te贸rica**

Hasta ahora se ha utilizado `delay()` para pausar el programa. Sin embargo, **`delay()` detiene completamente la ejecuci贸n del c贸digo**, impidiendo realizar otras tareas mientras se espera.

La funci贸n `millis()` devuelve el n煤mero de milisegundos transcurridos desde que se inici贸 el programa. Usando esta funci贸n es posible implementar **temporizadores no bloqueantes**, lo que permite ejecutar m煤ltiples acciones de manera simult谩nea.

>  Este enfoque es clave para sistemas que deben monitorear sensores, controlar salidas y responder a eventos al mismo tiempo.

---

### **2. Material necesario**

* Arduino Uno, Nano o ESP32.
* 1 LED.
* 1 resistencia de 220 ohms.
* Protoboard y cables.
* Computadora con el IDE de Arduino.
* Cable USB.

---

### **3. Diagrama de conexi贸n**

* LED conectado al pin 8 (o cualquier pin digital disponible).
* Resistencia de 220 ohms en serie.

```
Pin 8 --> [220惟] --> nodo del LED --> C谩todo --> GND
```

---

### **4. C贸digo base de la pr谩ctica**

```cpp
const int pinLED = 8;
unsigned long intervalo = 500; // Intervalo en milisegundos (0.5 segundos)
unsigned long tiempoAnterior = 0;
bool estadoLED = false;

void setup() {
  pinMode(pinLED, OUTPUT);
}

void loop() {
  unsigned long tiempoActual = millis();

  if (tiempoActual - tiempoAnterior >= intervalo) {
    tiempoAnterior = tiempoActual;

    estadoLED = !estadoLED; // Cambia el estado del LED
    digitalWrite(pinLED, estadoLED ? HIGH : LOW);
  }
}
```

---

### **5. Explicaci贸n paso a paso**

#### **5.1. Variable `millis()`**

```cpp
unsigned long tiempoActual = millis();
```

* Lee el tiempo actual en milisegundos desde que se encendi贸 el microcontrolador.

#### **5.2. Comparaci贸n temporal**

```cpp
if (tiempoActual - tiempoAnterior >= intervalo)
```

* Verifica si ha pasado el intervalo deseado desde la 煤ltima vez que se cambi贸 el estado del LED.

#### **5.3. Actualizaci贸n del estado**

```cpp
estadoLED = !estadoLED;
digitalWrite(pinLED, estadoLED ? HIGH : LOW);
```

* Cambia el estado del LED sin bloquear el c贸digo con `delay()`.

---

### **6. Ventajas de `millis()` sobre `delay()`**

| `millis()`                        | `delay()`                          |
| --------------------------------- | ---------------------------------- |
| No bloquea el programa            | Bloquea el flujo                   |
| Permite ejecutar m煤ltiples tareas | Solo se ejecuta una tarea a la vez |
| Ideal para sistemas reactivos     | Solo 煤til para tareas simples      |

---

### **7. Actividad de comprobaci贸n**

> **Ejercicio:** Modificar el c贸digo para que:
>
> 1. Un **segundo LED** conectado al pin 9 parpadee con un **intervalo diferente** (por ejemplo, cada 800 ms).
> 2. El primer LED (pin 8) parpadee cada 300 ms.
> 3. Ambos LEDs funcionen de manera **independiente y simult谩nea** sin usar `delay()`.

> **Pistas:**
>
> * Se deben usar **dos variables independientes** para `tiempoAnterior` e `intervalo` para cada LED.
> * Se puede repetir la misma estructura de temporizaci贸n por separado para cada LED.
