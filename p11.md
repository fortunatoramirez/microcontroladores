## **Pr√°ctica 11: Control de Brillo de un LED usando PWM**

### **Objetivo de la pr√°ctica**

Comprender y aplicar el uso de salidas PWM para simular se√±ales anal√≥gicas mediante el control del **brillo de un LED**. El alumno utilizar√° la funci√≥n `analogWrite()` para variar la intensidad del LED a trav√©s de diferentes niveles de se√±al digital modulada.

---

### **1. Introducci√≥n te√≥rica**

Los microcontroladores no pueden generar una verdadera se√±al anal√≥gica, pero pueden **simularla mediante PWM (Pulse Width Modulation)**. Esta t√©cnica consiste en enviar una se√±al digital que alterna r√°pidamente entre `HIGH` y `LOW`, variando el **tiempo encendido** frente al **tiempo apagado** en cada ciclo.

Este "porcentaje de encendido" se conoce como **ciclo de trabajo (duty cycle)** y se interpreta por dispositivos como un valor intermedio entre 0V y 5V.

* Un ciclo de trabajo del **0%** ‚Üí LED apagado.
* Un ciclo de trabajo del **100%** ‚Üí LED encendido al m√°ximo.
* Un ciclo de trabajo del **50%** ‚Üí LED con brillo medio.

> üí° En Arduino, `analogWrite()` acepta valores entre `0` (0%) y `255` (100%).

---

### **2. Material necesario**

* Arduino Uno, Nano o ESP32.
* 1 LED.
* 1 resistencia de 220 ohms.
* Protoboard y cables.
* Computadora con IDE de Arduino.
* Cable USB.

---

### **3. Diagrama de conexi√≥n**

* LED conectado al pin **PWM** (ej. pin 9 en Arduino Uno).
* C√°todo del LED conectado a GND.
* √Ånodo del LED conectado a resistencia de 220 ohms ‚Üí pin 9.

---

### **4. C√≥digo base de la pr√°ctica**

```cpp
const int pinLED = 9; // Pin PWM

void setup() {
  pinMode(pinLED, OUTPUT);
}

void loop() {
  // Aumentar brillo
  for (int brillo = 0; brillo <= 255; brillo++) {
    analogWrite(pinLED, brillo);    // Cambia el ciclo de trabajo
    delay(10);                      // Espera para ver el cambio
  }

  delay(500); // Pausa entre ciclos

  // Disminuir brillo
  for (int brillo = 255; brillo >= 0; brillo--) {
    analogWrite(pinLED, brillo);
    delay(10);
  }

  delay(500);
}
```

---

### **5. Explicaci√≥n paso a paso**

#### **5.1. Uso de `analogWrite()`**

```cpp
analogWrite(pinLED, brillo);
```

* Env√≠a una se√±al PWM al pin seleccionado.
* `brillo` var√≠a de 0 (apagado) a 255 (m√°ximo brillo).

#### **5.2. Ciclos de aumento/disminuci√≥n**

* Dos ciclos `for` que modifican el valor de `brillo` para hacer que el LED se encienda y se apague suavemente (efecto de ‚Äú*fade*‚Äù).

---

### **6. Pines PWM disponibles**

En el Arduino Uno, los pines PWM est√°n marcados con el s√≠mbolo `~` y son:

```
3, 5, 6, 9, 10, 11
```

En ESP32, cualquier pin puede usarse como PWM, pero se requiere `ledcWrite()` en lugar de `analogWrite()`. Para esta pr√°ctica, se recomienda usar Arduino Uno o Nano.

---

### **7. Visualizaci√≥n con el monitor serial (opcional)**

El valor de brillo puede mostrarse en el monitor serial para seguimiento:

```cpp
Serial.begin(9600);
Serial.println(brillo);
```

---

### **8. Actividad de comprobaci√≥n**

> **Ejercicio:** Modificar el c√≥digo para que:
>
> 1. El LED **aumente el brillo de 0 a 255 en pasos de 51** (es decir, 0%, 20%, 40%, ... hasta 100%).
> 2. Cada paso debe durar **400 milisegundos**.
> 3. Una vez alcanzado el brillo m√°ximo, debe **mantenerse encendido durante 2 segundos**, y luego apagarse totalmente.
> 4. Mostrar en el monitor serial el porcentaje de brillo (por ejemplo: ‚ÄúBrillo: 60%‚Äù).

> **Pistas:**
>
> * Puedes usar `map(valor, 0, 255, 0, 100)` para convertir el valor de PWM a porcentaje.
> * Recuerda que 255 / 5 = 51.
