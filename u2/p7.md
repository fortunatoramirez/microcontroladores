## **Práctica 7: Apuntadores, referencias y estructuras dinámicas de datos**

### **Objetivo de la práctica**

Comprender y aplicar el uso de apuntadores y referencias en C++ para manipular datos, arreglos, cadenas de texto y estructuras. El alumno aprenderá a acceder, modificar y gestionar información utilizando tanto memoria directa como referencias a memoria, reforzando el vínculo entre hardware y software.

---

### **1. Introducción teórica**

En un microcontrolador, cada variable ocupa una dirección de memoria. C++ permite trabajar no solo con los valores almacenados en esas direcciones, sino también con las **propias direcciones**, lo que es clave para el acceso eficiente y flexible a datos, especialmente en recursos limitados.

#### 1.1. Apuntadores (`*` y `&`)

* El operador `&` obtiene la **dirección de una variable**.
* El operador `*` accede al **valor contenido en una dirección** (de-referencia).

```cpp
int a = 5;
int* ptr = &a;   // ptr apunta a la dirección de a
*ptr = 10;       // modifica a través del puntero
```

#### 1.2. Referencias

Una **referencia** es un alias para una variable existente. Permite modificar directamente el contenido sin usar un puntero explícito.

```cpp
void incrementar(int& x) {
  x++;
}
```

#### 1.3. Apuntadores y arreglos

Un arreglo en C++ se comporta como un apuntador al primer elemento. Esto permite recorrer arreglos utilizando punteros.

```cpp
int valores[] = {10, 20, 30};
int* p = valores;

for (int i = 0; i < 3; i++) {
  Serial.println(*(p + i));
}
```

#### 1.4. Cadenas y funciones

Las **cadenas de texto** (`char*` o `const char*`) son arreglos de caracteres. Muchas funciones como `atoi()` operan sobre ellas para convertir texto a números.

#### 1.5. Casting

C++ permite **convertir tipos de datos explícitamente**. Esto se llama *type casting*, y es útil cuando es necesario reinterpretar un tipo, como pasar de un tipo constante a uno modificable o viceversa.

---

### **2. Material necesario**

* ESP32, Arduino Uno o Nano
* 1 LED
* Protoboard, cables
* Computadora con IDE de Arduino

---

### **3. Código base de la práctica**

#### **3.1. Apuntadores y referencias básicas**

```cpp
int valor = 50;
int* ptr = &valor;
int& ref = valor;

void setup() {
  Serial.begin(9600);
  *ptr = 80;       // modifica valor
  ref += 20;       // también modifica valor

  Serial.print("Valor: "); Serial.println(valor);       // 100
  Serial.print("Desde ptr: "); Serial.println(*ptr);    // 100
  Serial.print("Desde ref: "); Serial.println(ref);     // 100
}
```

---

#### **3.2. Arreglos con punteros y strings**

```cpp
void setup() {
  Serial.begin(9600);
  
  char texto[] = "1234";
  int numero = atoi(texto);  // convierte cadena numérica a entero

  Serial.print("Cadena: "); Serial.println(texto);
  Serial.print("Entero convertido: "); Serial.println(numero);

  // Arreglo con puntero
  int datos[] = {1, 2, 3, 4};
  int* p = datos;

  for (int i = 0; i < 4; i++) {
    Serial.print("Dato "); Serial.print(i); Serial.print(": ");
    Serial.println(*(p + i));
  }
}
```

---

#### **3.3. Función con referencia vs función con puntero**

```cpp
struct Registro {
  float valor;
};

// Con referencia
void actualizarPorReferencia(Registro& r, float nuevo) {
  r.valor = nuevo;
}

// Con puntero
void actualizarPorPuntero(Registro* r, float nuevo) {
  r->valor = nuevo;
}

Registro r1 = {10.5};

void setup() {
  Serial.begin(9600);
  actualizarPorReferencia(r1, 20.0);
  Serial.print("Actualizado (referencia): "); Serial.println(r1.valor);

  actualizarPorPuntero(&r1, 35.0);
  Serial.print("Actualizado (puntero): "); Serial.println(r1.valor);
}
```

---

#### **3.4. Casting aplicado**

```cpp
void convertir(const char* cadena) {
  int numero = atoi(cadena);  // No se necesita cast
  Serial.print("Número: "); Serial.println(numero);
}

void setup() {
  Serial.begin(9600);

  const char* mensaje = "456";
  convertir(mensaje);

  // Cast explícito necesario (menos común pero válido)
  char buffer[] = "789";
  int n = atoi((char*)buffer); // cast no es obligatorio pero posible
  Serial.print("Número cast: "); Serial.println(n);
}
```

---

### **4. Explicación paso a paso**

* **Apuntadores** permiten modificar datos directamente en memoria.
* **Referencias** son más legibles y seguras, ideales en funciones.
* **Arreglos y punteros** son equivalentes al recorrer memoria contigua.
* **Cadenas** se manejan como `char*` y pueden convertirse fácilmente a enteros.
* **Casting** debe usarse cuando se requiere una reinterpretación explícita del tipo de dato.

---

### **5. Actividad de comprobación**

> Realizar un programa que:

1. Declare un arreglo de enteros de tamaño 6.
2. Llene el arreglo con valores del 1 al 6 usando un puntero.
3. Cree una función que reciba una referencia a un `struct` que contenga un campo `byte suma` y un campo `char mensaje[10]`.
4. Dentro de esa función:

   * Calcule la suma del arreglo usando punteros.
   * Guarde la palabra `"Hecho"` en el campo `mensaje` usando `strcpy()` y punteros.
5. En el `setup()`, imprima el contenido del struct: suma y mensaje.

