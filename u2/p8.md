

## **Bloque 1: Directivas del preprocesador en C++**

### **1. Introducción teórica**

En C/C++, las directivas del preprocesador comienzan con el símbolo `#` y son instrucciones que se procesan **antes** de compilar el programa. No forman parte del lenguaje C++ en sí, sino que se ejecutan durante la fase de preprocesamiento.

Estas directivas permiten:

* Definir constantes simbólicas.
* Incluir archivos externos (`.h`).
* Activar o desactivar partes del código según condiciones.

#### 1.1. `#define`

Permite crear una constante simbólica. No ocupa memoria y es sustituida por su valor **en tiempo de compilación**.

```cpp
#define PI 3.1416
#define LED 2
```

Esto reemplaza todas las apariciones de `PI` y `LED` por sus valores respectivos antes de compilar.

#### 1.2. `#include`

Inserta el contenido de otro archivo en el programa. Se usa para agregar bibliotecas externas o definiciones propias:

```cpp
#include <Arduino.h>     // Biblioteca estándar
#include "mibiblioteca.h" // Archivo creado por el usuario
```

#### 1.3. `#ifdef`, `#ifndef`, `#endif`

Permiten compilar condicionalmente partes del código:

```cpp
#define MODO_DEBUG

#ifdef MODO_DEBUG
  Serial.println("Modo depuración activo");
#endif
```

Este fragmento se compilará solo si `MODO_DEBUG` ha sido definido.

#### 1.4. `#if`, `#else`, `#elif`

Se utilizan para evaluar condiciones más complejas:

```cpp
#define VERSION 2

#if VERSION == 1
  #define VELOCIDAD 100
#elif VERSION == 2
  #define VELOCIDAD 200
#else
  #define VELOCIDAD 50
#endif
```

Esto permite cambiar comportamientos del programa dependiendo de una constante definida.

---

### **2. Ejemplo de código base**

```cpp
#define MODO_DEBUG
#define LED 2

void setup() {
  pinMode(LED, OUTPUT);
  Serial.begin(9600);

  #ifdef MODO_DEBUG
    Serial.println("Depuración activada");
  #endif
}

void loop() {
  digitalWrite(LED, HIGH);
  delay(500);
  digitalWrite(LED, LOW);
  delay(500);

  #ifdef MODO_DEBUG
    Serial.println("LED encendido y apagado");
  #endif
}
```

---

### **3. Explicación paso a paso**

* `#define LED 2`: Define una constante para usar en lugar del número de pin.
* `#ifdef MODO_DEBUG`: El bloque de código que contiene `Serial.println()` solo se compila si `MODO_DEBUG` fue definido.
* Esto permite **activar o desactivar** funciones fácilmente para diferentes versiones del programa.

---

### **4. Ventajas del uso del preprocesador**

| Ventaja                        | Descripción                                                 |
| ------------------------------ | ----------------------------------------------------------- |
| Ahorro de memoria              | `#define` no ocupa RAM.                                     |
| Control condicional del código | Se puede compilar o excluir bloques según condiciones.      |
| Legibilidad y mantenimiento    | Uso de constantes simbólicas mejora la claridad del código. |
| Modularidad                    | Permite separar configuraciones o versiones del código.     |

---

### **5. Actividad de comprobación**

> **Ejercicio 1:**
>
> 1. Define `#define VELOCIDAD_LED 300`
> 2. Crea un programa que haga parpadear un LED conectado al pin 13 usando ese valor.
> 3. Agrega una directiva `#ifdef DEPURAR` que imprima `"LED ON"` y `"LED OFF"` cada vez que se cambie el estado del LED.
> 4. Comenta o descomenta `#define DEPURAR` y observa cómo el código cambia automáticamente.

---

## **Bloque 2: Creación de bibliotecas personalizadas (.h y .cpp)**

### **1. Introducción teórica**

En proyectos más complejos, dividir el código en archivos ayuda a organizar, reutilizar y mantener el proyecto más limpio. Para eso, se crean **bibliotecas personalizadas** usando archivos `.h` (cabecera) y `.cpp` (implementación).

Esto permite encapsular funciones, estructuras y constantes en módulos reutilizables.

#### 1.1. Archivo `.h` (header o cabecera)

Contiene las declaraciones de funciones, estructuras, variables externas y directivas del preprocesador. No contiene código ejecutable, solo definiciones.

```cpp
// miSensor.h
#ifndef MISENSOR_H
#define MISENSOR_H

void inicializarSensor();
float leerSensor();

#endif
```

#### 1.2. Archivo `.cpp`

Contiene la implementación de las funciones declaradas en el archivo `.h`.

```cpp
// miSensor.cpp
#include "miSensor.h"

void inicializarSensor() {
  // simulación de inicialización
  Serial.println("Sensor listo");
}

float leerSensor() {
  return analogRead(A0) * (5.0 / 1023.0);
}
```

#### 1.3. Inclusión en el programa principal

```cpp
#include <Arduino.h>
#include "miSensor.h"

void setup() {
  Serial.begin(9600);
  inicializarSensor();
}

void loop() {
  float valor = leerSensor();
  Serial.print("Valor leído: ");
  Serial.println(valor);
  delay(1000);
}
```

---

### **2. ¿Qué hace `#ifndef`, `#define`, `#endif`?**

Son mecanismos de **protección contra inclusión múltiple**, también conocidos como *include guards*. Aseguran que el contenido del archivo `.h` solo se incluya una vez, incluso si se hace referencia varias veces en diferentes archivos.

---

### **3. Ventajas del uso de bibliotecas propias**

| Ventaja              | Descripción                                              |
| -------------------- | -------------------------------------------------------- |
| Organización modular | Facilita la lectura y depuración.                        |
| Reutilización        | Se puede usar en varios proyectos.                       |
| Separación de lógica | El código principal queda limpio y enfocado.             |
| Escalabilidad        | Ideal para proyectos que crecen en tamaño y complejidad. |

---

### **4. Actividad de comprobación**

> **Ejercicio 2:**
>
> 1. Crea un archivo llamado `ledControl.h` con la declaración de dos funciones:
>
>    * `void encenderLed(byte pin);`
>    * `void apagarLed(byte pin);`
>
> 2. Crea un archivo llamado `ledControl.cpp` con la implementación de esas funciones usando `digitalWrite()`.
>
> 3. En el programa principal (`.ino`):
>
>    * Incluye el archivo `.h`
>    * En `setup()`, configura el pin 5 como salida.
>    * En `loop()`, alterna entre encender y apagar el LED con un `delay(500)`.
>
> 4. Usa `#define LED_PIN 5` en el archivo `.ino`.

---

## **Bloque 3: Estructuras complejas con apuntadores**

### **1. Introducción teórica**

Las **estructuras (`struct`)** permiten agrupar múltiples variables de diferentes tipos en un solo objeto. Cuando se combinan con **apuntadores**, se pueden manipular estructuras dinámicamente, pasar por referencia, recorrer arreglos de estructuras, o gestionar información más eficiente.

También es posible acceder a miembros de una estructura tanto con el operador punto (`.`) como con el operador flecha (`->`) si se trabaja con un apuntador.

---

### **2. Declaración y uso de estructuras**

```cpp
struct Sensor {
  uint8_t id;
  float temperatura;
  float humedad;
};
```

#### 2.1. Declaración e inicialización

```cpp
Sensor s1 = {1, 36.5, 42.0};
```

#### 2.2. Acceso por valor y por referencia

```cpp
void imprimirSensor(const Sensor& s) {
  Serial.print("ID: "); Serial.print(s.id);
  Serial.print(" | Temp: "); Serial.print(s.temperatura);
  Serial.print(" | Hum: "); Serial.println(s.humedad);
}
```

---

### **3. Apuntadores a estructuras**

Cuando se trabaja con apuntadores, se usa el operador `->` para acceder a los miembros.

```cpp
Sensor sensor2 = {2, 30.1, 50.0};
Sensor* ptrSensor = &sensor2;

Serial.print("ID: ");
Serial.println(ptrSensor->id);  // Equivalente a (*ptrSensor).id
```

#### 3.1. Paso de estructura por puntero

```cpp
void modificar(Sensor* s) {
  s->temperatura += 1.5;
  s->humedad -= 2.0;
}
```

---

### **4. Arreglos de estructuras con apuntadores**

```cpp
Sensor sensores[3] = {
  {1, 36.0, 45.0},
  {2, 34.5, 50.2},
  {3, 37.1, 40.8}
};

void imprimirTodo(Sensor* arreglo, byte cantidad) {
  for (byte i = 0; i < cantidad; i++) {
    Serial.print("Sensor "); Serial.print(i);
    Serial.print(" - T: "); Serial.print(arreglo[i].temperatura);
    Serial.print(" H: "); Serial.println(arreglo[i].humedad);
  }
}
```

---

### **5. Ejemplo completo**

```cpp
struct Sensor {
  uint8_t id;
  float temperatura;
  float humedad;
};

Sensor s1 = {1, 36.5, 42.0};
Sensor* ps = &s1;

void setup() {
  Serial.begin(9600);
  Serial.print("Temp antes: ");
  Serial.println(ps->temperatura);

  modificar(ps);

  Serial.print("Temp después: ");
  Serial.println(ps->temperatura);
}

void modificar(Sensor* s) {
  s->temperatura += 2.0;
  s->humedad += 5.0;
}
```

---

### **6. Actividad de comprobación**

> **Ejercicio 3:**
>
> 1. Define una estructura llamada `Paciente` que contenga:
>
>    * `char nombre[20]`
>    * `byte edad`
>    * `float presion`
> 2. Crea una variable global de tipo `Paciente` llamada `p1`.
> 3. Crea una función que reciba un apuntador a `Paciente` y:
>
>    * Copie el nombre `"Luis"` usando `strcpy()`
>    * Le asigne edad y presión
> 4. En el `setup()`, llama a esta función y luego imprime sus valores con `Serial`.

---

## **Bloque 4: Máquina de Estados Finita (FSM)**

### **1. Introducción teórica**

Una **máquina de estados finita** (FSM, por sus siglas en inglés) es un modelo de programación muy utilizado para controlar sistemas que tienen múltiples comportamientos posibles, dependiendo de su "estado actual". Cada estado define un conjunto de acciones, y las transiciones entre estados se producen con base en condiciones o eventos.

Este enfoque es ideal en sistemas embebidos para controlar menús, procesos secuenciales, gestión de sensores o máquinas automáticas.

Una FSM consta de:

* Un **estado actual**.
* Una serie de **estados definidos**.
* **Condiciones o eventos** que determinan la transición entre estados.

---

### **2. Enumeraciones (`enum`) para definir estados**

Para definir los estados de forma clara, se utiliza `enum`, una lista de valores simbólicos:

```cpp
enum Estado {
  ESPERANDO,
  LEYENDO,
  PROCESANDO,
  TERMINADO
};
```

Esto permite declarar una variable que solo puede contener uno de esos estados:

```cpp
Estado estadoActual = ESPERANDO;
```

---

### **3. Estructura típica de una FSM**

```cpp
void loop() {
  switch (estadoActual) {
    case ESPERANDO:
      // Código para el estado ESPERANDO
      if (condicion) estadoActual = LEYENDO;
      break;

    case LEYENDO:
      // Código para el estado LEYENDO
      estadoActual = PROCESANDO;
      break;

    case PROCESANDO:
      // Código para PROCESANDO
      estadoActual = TERMINADO;
      break;

    case TERMINADO:
      // Reiniciar o detener FSM
      break;
  }
}
```

---

### **4. Ejemplo completo: FSM para control por botón**

Este ejemplo utiliza un botón para recorrer cuatro estados: **Apagado**, **Encendido débil**, **Encendido fuerte**, y **Apagado final**.

```cpp
enum EstadoLED {
  APAGADO,
  BAJO,
  ALTO
};

EstadoLED estadoActual = APAGADO;
const int pinBoton = 4;
const int pinLED = 2;
bool presionado = false;

void setup() {
  pinMode(pinBoton, INPUT_PULLUP);
  pinMode(pinLED, OUTPUT);
  Serial.begin(9600);
}

void loop() {
  if (digitalRead(pinBoton) == LOW && !presionado) {
    presionado = true;

    // Cambia de estado
    switch (estadoActual) {
      case APAGADO:
        estadoActual = BAJO;
        break;
      case BAJO:
        estadoActual = ALTO;
        break;
      case ALTO:
        estadoActual = APAGADO;
        break;
    }

    delay(200); // Antirrebote básico
  }

  if (digitalRead(pinBoton) == HIGH) {
    presionado = false;
  }

  // Ejecuta el comportamiento del estado actual
  switch (estadoActual) {
    case APAGADO:
      analogWrite(pinLED, 0);
      break;
    case BAJO:
      analogWrite(pinLED, 50);
      break;
    case ALTO:
      analogWrite(pinLED, 255);
      break;
  }
}
```

---

### **5. Actividad de comprobación**

> **Ejercicio 4:**
>
> Diseñar una FSM que simule un sistema de 3 pasos:
>
> 1. Estado `INICIO`: espera que un botón sea presionado.
> 2. Estado `CAPTURA`: simula la lectura de datos (ej. mostrar en Serial “leyendo…”).
> 3. Estado `ENVIO`: imprime “datos enviados”.
>
> Luego de `ENVIO`, debe volver a `INICIO`.

---

****************************************************
