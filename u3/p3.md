# **Práctica 3 — Sistema distribuido multiprotocolo: monitoreo autónomo con sensores, microcontroladores interconectados y servidor en computadora**

### **Objetivo general**

Implementar un sistema distribuido biomédico compuesto por múltiples microcontroladores ESP32 interconectados mediante Bluetooth clásico y WiFi, en conjunto con una estación central basada en una computadora personal, con el fin de adquirir, transmitir, visualizar y consultar señales fisiológicas en una red local. Cada nodo operará de forma autónoma con alimentación por batería, integrando sensores reales, pantallas, teclados y protocolos de comunicación inalámbrica.

---

### **Descripción general del sistema**

Este proyecto busca simular una red biomédica distribuida en la que distintos dispositivos recolectan datos fisiológicos, los transmiten por Bluetooth a nodos intermedios, y estos a su vez reenvían la información por WiFi hacia una estación central que actúa como servidor. El sistema contempla cuatro nodos principales:

* **Nodo 1 – Sensor biomédico con Bluetooth**
  Microcontrolador ESP32 con sensor físico (como el MAX30102 o LM35), encargado de adquirir datos del paciente (por ejemplo, frecuencia cardiaca o temperatura) y transmitirlos periódicamente vía Bluetooth clásico. El nodo opera de manera autónoma, mostrando los datos localmente en pantalla OLED o LCD.

* **Nodo 2 – Puente Bluetooth/WiFi**
  Microcontrolador ESP32 encargado de recibir los datos vía Bluetooth desde el Nodo 1 y reenviarlos mediante WiFi hacia un servidor central. Este nodo integra un teclado matricial para la gestión de pacientes o identificación, y una pantalla para visualización de datos o estado de conexión.

* **Nodo 3 – Servidor en computadora**
  Estación central basada en PC (con software en Python o Node.js), encargada de recibir los datos por WiFi desde el Nodo 2, visualizarlos en consola o navegador web, y opcionalmente almacenarlos en una base de datos o archivo local.

* **Nodo 4 – Cliente remoto**
  Puede ser un ESP32 adicional o un navegador en un celular o computadora que consulta el servidor para acceder a los datos recibidos. Este nodo actúa como herramienta de visualización externa o portátil.

---

### **Tecnologías involucradas**

* **Bluetooth clásico (SPP)** para comunicación local entre nodos ESP32.
* **WiFi (modo cliente/estación)** para envío de datos hacia el servidor.
* **HTTP o WebSocket** como protocolo de red para la comunicación con la PC.
* **Pantallas OLED o LCD** para mostrar lecturas o información del sistema.
* **Teclado matricial 4x4** para navegación, entrada de identificadores o selección de nodos.
* **Sensores biomédicos reales**, como el MAX30102 o el LM35.
* **Servidor en PC** capaz de recibir y mostrar datos en tiempo real.

---

### **Distribución por equipos**

La práctica se desarrollará en equipos de cuatro integrantes. Cada persona será responsable de uno de los nodos descritos anteriormente. El éxito del sistema depende de la correcta colaboración e integración de los módulos desarrollados por cada miembro del equipo.

## Bloque 1 – Nodo 1: Adquisición de señal biomédica y transmisión por Bluetooth clásico

### Objetivo del bloque

Configurar un microcontrolador ESP32 que funcione como nodo de adquisición biomédica, capturando señales fisiológicas mediante un sensor digital o analógico (como el MAX30102 o el LM35), visualizando los datos localmente en una pantalla OLED o LCD, y transmitiéndolos de forma inalámbrica por Bluetooth clásico (SPP) hacia el nodo intermedio.

---

### Introducción teórica

Los microcontroladores ESP32 permiten integrar sensores biomédicos tanto digitales como analógicos, y pueden enviar los datos adquiridos a otros dispositivos mediante Bluetooth clásico. Este tipo de comunicación inalámbrica es adecuada para enlaces de corto alcance y bajo consumo, como los que se presentan entre dispositivos corporales o portátiles.

En este bloque, cada alumno implementará un nodo autónomo que funciona como unidad de captura de señales, alimentado por batería, y capaz de mostrar localmente las lecturas y enviarlas por Bluetooth.

---

### Material necesario

* ESP32 con soporte para Bluetooth clásico.
* Sensor biomédico:

  * Sensor digital (por ejemplo, MAX30102).
  * Sensor analógico (por ejemplo, LM35, TMP36, etc.).
* Pantalla:

  * OLED 128x32 o 128x64 (I2C).
  * LCD 16x2 con módulo I2C.
* Cables y protoboard.
* Batería USB o banco de energía.

---

### Código base – Versión con sensor analógico (ej. LM35)

A continuación se presenta el código base para un sensor analógico y dos versiones de pantalla: OLED y LCD. El alumno debe elegir una según el componente disponible.

#### Configuración común

```cpp
#include <BluetoothSerial.h>
BluetoothSerial SerialBT;

const int pinSensor = 34;  // Entrada analógica
float temperatura = 0;
unsigned long t0 = 0;
```

#### Versión con OLED (128x32 o 128x64)

```cpp
#include <Wire.h>
#include <U8g2lib.h>

// Descomentar según el modelo de pantalla:
// U8G2_SSD1306_128X64_NONAME_F_HW_I2C display(U8G2_R0, U8X8_PIN_NONE);
U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C display(U8G2_R0, U8X8_PIN_NONE);

void setup() {
  SerialBT.begin("Nodo1_Bluetooth");  // Nombre Bluetooth visible
  display.begin();
  display.clearBuffer();
  display.setFont(u8g2_font_6x10_tf);
}

void loop() {
  if (millis() - t0 > 2000) {
    int valorADC = analogRead(pinSensor);
    temperatura = (valorADC * 3.3 / 4095.0) * 100;  // Para LM35: 10 mV/°C

    String mensaje = "Temp:" + String(temperatura, 1) + " C";
    SerialBT.println(mensaje);

    display.clearBuffer();
    display.drawStr(0, 15, "Sensor: LM35");
    display.drawStr(0, 30, mensaje.c_str());
    display.sendBuffer();

    t0 = millis();
  }
}
```

#### Versión con LCD 16x2 (I2C)

```cpp
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x27, 16, 2);  // Ajustar dirección si es necesario

void setup() {
  SerialBT.begin("Nodo1_Bluetooth");
  lcd.init();
  lcd.backlight();
}

void loop() {
  if (millis() - t0 > 2000) {
    int valorADC = analogRead(pinSensor);
    temperatura = (valorADC * 3.3 / 4095.0) * 100;

    String mensaje = "Temp:" + String(temperatura, 1) + " C";
    SerialBT.println(mensaje);

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Sensor: LM35");
    lcd.setCursor(0, 1);
    lcd.print(mensaje);

    t0 = millis();
  }
}
```

---

### Alternativa – Código base con sensor digital MAX30102

Para sensores digitales como el MAX30102, se requiere instalar la librería adecuada (por ejemplo, [SparkFun MAX3010x Sensor Library](https://github.com/sparkfun/SparkFun_MAX3010x_Sensor_Library)).

```cpp
#include <Wire.h>
#include <MAX30105.h>
#include <BluetoothSerial.h>
#include <U8g2lib.h>

MAX30105 particleSensor;
BluetoothSerial SerialBT;
U8G2_SSD1306_128X64_NONAME_F_HW_I2C display(U8G2_R0, U8X8_PIN_NONE);

unsigned long t0 = 0;

void setup() {
  Serial.begin(115200);
  SerialBT.begin("Nodo1_Bluetooth");
  Wire.begin();
  display.begin();
  display.setFont(u8g2_font_6x10_tf);

  if (!particleSensor.begin(Wire, I2C_SPEED_STANDARD)) {
    while (1);  // Sensor no encontrado
  }
  particleSensor.setup();  // Configuración por defecto
}

void loop() {
  if (millis() - t0 > 2000) {
    uint32_t ir = particleSensor.getIR();

    String mensaje = "IR: " + String(ir);
    SerialBT.println(mensaje);

    display.clearBuffer();
    display.drawStr(0, 15, "Sensor: MAX30102");
    display.drawStr(0, 30, mensaje.c_str());
    display.sendBuffer();

    t0 = millis();
  }
}
```

---

### Actividad de comprobación

1. Conectar el sensor elegido al ESP32 y verificar que las lecturas se muestren correctamente en la pantalla local.
2. Conectar el ESP32 a una batería externa y validar su funcionamiento autónomo.
3. Verificar, desde el monitor serial de una PC o desde otro dispositivo con Bluetooth, que los datos se están transmitiendo correctamente.
4. Hacer capturas o video de funcionamiento para validación del equipo docente.


## Bloque 2 – Nodo 2: Receptor Bluetooth y transmisor WiFi con pantalla y teclado

### Objetivo del bloque

Implementar un nodo intermedio que reciba datos biomédicos por Bluetooth desde un nodo sensor, los visualice en una pantalla local (OLED o LCD), permita la interacción del usuario mediante un teclado matricial 4x4, y reenvíe los datos por WiFi a un servidor en una computadora. Este nodo también opera de forma autónoma con alimentación por batería.

---

### Introducción teórica

El uso de un nodo intermedio como puente entre tecnologías de corto y mediano alcance (Bluetooth y WiFi) permite separar funciones en un sistema distribuido. En esta práctica, el nodo 2 recibe datos por Bluetooth clásico (SPP), los asocia con una entrada local (como un ID de paciente ingresado por teclado), y los transmite por WiFi mediante una solicitud HTTP POST al servidor ubicado en una computadora de la red local.

Este nodo también brinda retroalimentación visual de todo el proceso mediante una pantalla, que permite confirmar la conexión, visualizar los datos recibidos y mostrar mensajes de estado.

---

### Material necesario

* ESP32 con soporte para Bluetooth y WiFi.
* Pantalla OLED 128x32 o 128x64, o LCD 16x2 con I2C.
* Teclado matricial 4x4.
* Resistencias tipo pull-down o módulo teclado con pines comunes.
* Cables, protoboard y batería.

---

### Código base – Recepción Bluetooth, entrada por teclado y reenvío por WiFi

#### Librerías requeridas

```cpp
#include <BluetoothSerial.h>
#include <WiFi.h>
#include <Wire.h>
#include <Keypad.h>
#include <LiquidCrystal_I2C.h>           // Para LCD
#include <U8g2lib.h>                     // Para OLED
#include <HTTPClient.h>
```

#### Configuración de periféricos

```cpp
// Bluetooth
BluetoothSerial SerialBT;

// WiFi
const char* ssid = "TuSSID";
const char* password = "TuPassword";
const char* serverUrl = "http://192.168.1.100:5000/datos"; // Cambiar IP/puerto según servidor

// Pantalla (elige una)
U8G2_SSD1306_128X64_NONAME_F_HW_I2C oled(U8G2_R0, U8X8_PIN_NONE);
// LiquidCrystal_I2C lcd(0x27, 16, 2);  // Descomentar si se usa LCD

// Teclado
const byte ROWS = 4; 
const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {19, 18, 5, 17};
byte colPins[COLS] = {16, 4, 2, 15};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

// Variables
String bufferBluetooth = "";
String idPaciente = "0000";
unsigned long t0 = 0;
```

#### `setup()`

```cpp
void setup() {
  Serial.begin(115200);
  SerialBT.begin("Nodo2_Bridge");
  
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
  }

  oled.begin();
  oled.setFont(u8g2_font_6x10_tf);
  oled.clearBuffer();
  oled.drawStr(0, 15, "Nodo 2 listo.");
  oled.sendBuffer();

  // lcd.init(); lcd.backlight();  // Descomentar si se usa LCD
}
```

#### `loop()`

```cpp
void loop() {
  // Leer teclado
  char key = keypad.getKey();
  if (key && key >= '0' && key <= '9') {
    idPaciente += key;
    if (idPaciente.length() > 4) idPaciente = idPaciente.substring(idPaciente.length()-4);
  }

  // Leer Bluetooth
  while (SerialBT.available()) {
    char c = SerialBT.read();
    if (c == '\n') {
      String mensaje = "ID:" + idPaciente + "," + bufferBluetooth;
      enviarWiFi(mensaje);
      mostrarEnPantalla(mensaje);
      bufferBluetooth = "";
    } else {
      bufferBluetooth += c;
    }
  }
}
```

#### Función para enviar datos por WiFi

```cpp
void enviarWiFi(String datos) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin(serverUrl);
    http.addHeader("Content-Type", "application/x-www-form-urlencoded");
    String body = "mensaje=" + datos;
    http.POST(body);
    http.end();
  }
}
```

#### Función para mostrar en pantalla

```cpp
void mostrarEnPantalla(String texto) {
  oled.clearBuffer();
  oled.drawStr(0, 15, "Enviado:");
  oled.drawStr(0, 30, texto.c_str());
  oled.sendBuffer();

  // lcd.clear(); lcd.setCursor(0, 0); lcd.print("Enviado:");
  // lcd.setCursor(0, 1); lcd.print(texto);  // Para LCD
}
```

---

### Actividad de comprobación

1. Verificar que el nodo reciba correctamente los datos enviados por Bluetooth desde el Nodo 1.
2. Ingresar una secuencia de números en el teclado (ID del paciente) y observar que se adjunta al mensaje.
3. Confirmar en el servidor que los datos están llegando por WiFi.
4. Validar que los datos se muestren en la pantalla del nodo de forma clara.
5. Probar el funcionamiento completo con batería y sin conexión a la computadora.

---

## Bloque 3 – Nodo 3: Servidor en computadora con página web para visualizar datos biomédicos

### Objetivo del bloque

Implementar un servidor web local en una computadora que reciba datos desde un ESP32 (Nodo 2) mediante peticiones HTTP POST y los muestre en una página web con estilo agradable. Se ofrecen dos versiones funcionalmente equivalentes: una en **Python con Flask** y otra en **Node.js con Express**. Ambas versiones permiten que los estudiantes comprendan que los mismos objetivos pueden alcanzarse usando distintos entornos de desarrollo.

---

### Introducción teórica

El ESP32 puede enviar datos por red WiFi a un servidor mediante solicitudes HTTP, un protocolo estándar para la web. Una vez que los datos llegan al servidor, pueden visualizarse en tiempo real en una página accesible desde la misma red. Tanto Flask como Express permiten crear servidores web ligeros y rápidos, ideales para aplicaciones locales o educativas.

El servidor que se implementará en este bloque contará con:

* Un endpoint `/datos` que recibe los datos enviados por el ESP32.
* Una página web (`/`) que muestra todos los datos recibidos.
* Estilo visual agradable para mejorar la experiencia del usuario.

---

### Requisitos previos

#### Para Flask:

* Tener Python 3 instalado.
* Instalar Flask:

  ```bash
  pip install flask
  ```

#### Para Node.js:

* Tener Node.js y npm instalados.
* Inicializar el proyecto y instalar dependencias:

  ```bash
  npm init -y
  npm install express body-parser
  ```

---

### Estructura del servidor (en ambas versiones)

```
Servidor en PC
├── Página web: muestra los datos recibidos
└── Endpoint /datos: recibe los POST del ESP32
```

---

### A. Versión en Python (Flask)

#### Archivo: `servidor.py`

```python
from flask import Flask, request, render_template_string
from datetime import datetime

app = Flask(__name__)
datos_recibidos = []

TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Datos Biomédicos</title>
  <style>
    body { font-family: sans-serif; background: #f4f4f4; margin: 2em; }
    h1 { color: #2c3e50; }
    table { border-collapse: collapse; width: 100%; background: white; }
    th, td { padding: 10px; border: 1px solid #ddd; text-align: left; }
    tr:nth-child(even) { background: #f9f9f9; }
  </style>
</head>
<body>
  <h1>Datos Biomédicos Recibidos</h1>
  <table>
    <tr><th>Fecha y hora</th><th>Mensaje</th></tr>
    {% for dato in datos %}
      <tr><td>{{ dato[0] }}</td><td>{{ dato[1] }}</td></tr>
    {% endfor %}
  </table>
</body>
</html>
"""

@app.route("/", methods=["GET"])
def index():
    return render_template_string(TEMPLATE, datos=datos_recibidos[::-1])

@app.route("/datos", methods=["POST"])
def recibir_datos():
    mensaje = request.form.get("mensaje")
    if mensaje:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        datos_recibidos.append((timestamp, mensaje))
    return "OK", 200

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
```

---

### B. Versión en Node.js (Express)

#### Archivo: `server.js`

```javascript
const express = require("express");
const bodyParser = require("body-parser");
const app = express();
const PORT = 5000;

let datosRecibidos = [];

app.use(bodyParser.urlencoded({ extended: false }));

app.get("/", (req, res) => {
  const tabla = datosRecibidos.slice().reverse().map(dato => `
    <tr><td>${dato.hora}</td><td>${dato.mensaje}</td></tr>
  `).join("");

  const html = `
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="UTF-8">
    <title>Datos Biomédicos</title>
    <style>
      body { font-family: sans-serif; background: #f4f4f4; margin: 2em; }
      h1 { color: #2c3e50; }
      table { border-collapse: collapse; width: 100%; background: white; }
      th, td { padding: 10px; border: 1px solid #ddd; text-align: left; }
      tr:nth-child(even) { background: #f9f9f9; }
    </style>
  </head>
  <body>
    <h1>Datos Biomédicos Recibidos</h1>
    <table>
      <tr><th>Fecha y hora</th><th>Mensaje</th></tr>
      ${tabla}
    </table>
  </body>
  </html>
  `;
  res.send(html);
});

app.post("/datos", (req, res) => {
  const mensaje = req.body.mensaje;
  if (mensaje) {
    const now = new Date();
    const hora = now.toISOString().replace("T", " ").substring(0, 19);
    datosRecibidos.push({ hora, mensaje });
  }
  res.send("OK");
});

app.listen(PORT, () => {
  console.log(`Servidor ejecutándose en http://localhost:${PORT}`);
});
```

---

### Actividad de comprobación

1. Elegir una de las dos versiones e instalar los paquetes necesarios.
2. Iniciar el servidor y verificar que esté accesible desde el navegador:
   `http://localhost:5000` o `http://<IP_local>:5000`
3. Ejecutar el Nodo 2 y verificar que los datos se visualicen correctamente.
4. Probar el acceso desde otro dispositivo conectado a la misma red local (Ej. celular o laptop).
5. Comprobar que los datos se actualizan correctamente y tienen formato legible.


---

## Bloque 4 – Nodo 4: Cliente remoto con ESP32 y pantalla para consulta de datos biomédicos

### Objetivo del bloque

Implementar un cliente remoto con ESP32 y pantalla que consulte periódicamente al servidor web alojado en una computadora (Nodo 3), para obtener y visualizar los datos biomédicos recibidos. Este nodo funcionará como una unidad de monitoreo portátil y autónoma. Además, se comprobará que otros dispositivos de la red local (como celulares o laptops) puedan acceder al mismo servidor para comparar la información mostrada.

---

### Introducción teórica

En una red distribuida, los clientes remotos pueden consultar al servidor principal para visualizar información sin necesidad de cables o interacción directa con los nodos sensores. En este bloque, el ESP32 actuará como cliente HTTP y consultará la última entrada de datos biomédicos desde el servidor local. La consulta se realiza mediante solicitudes GET, extrayendo los datos más recientes y mostrándolos en pantalla.

Este tipo de cliente también puede implementarse en navegadores de otros dispositivos (celulares o PCs) para validar el correcto despliegue del servidor y su accesibilidad en la red.

---

### Material necesario

* ESP32 con WiFi.
* Pantalla OLED 128x32 o 128x64, o LCD 16x2 con I2C.
* Cables, protoboard y batería externa.
* Celular o laptop conectados a la misma red WiFi que el servidor.

---

### Diagrama lógico del nodo

```
(Servidor HTTP) <-- (GET) <-- [ESP32 con pantalla]
                            |
                   [Celular o navegador]
```

---

### Código base – Consulta HTTP GET y visualización en pantalla

#### Librerías requeridas

```cpp
#include <WiFi.h>
#include <HTTPClient.h>
#include <Wire.h>
#include <U8g2lib.h>             // Para OLED
#include <LiquidCrystal_I2C.h>   // Para LCD
```

#### Configuración WiFi y pantalla

```cpp
const char* ssid = "TuSSID";
const char* password = "TuPassword";

// IP local del servidor (cambiar según tu red)
const char* serverUrl = "http://192.168.1.100:5000/";

U8G2_SSD1306_128X64_NONAME_F_HW_I2C oled(U8G2_R0, U8X8_PIN_NONE);
// LiquidCrystal_I2C lcd(0x27, 16, 2);  // Descomentar si se usa LCD

unsigned long t0 = 0;
```

#### `setup()`

```cpp
void setup() {
  Serial.begin(115200);

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
  }

  oled.begin();
  oled.setFont(u8g2_font_6x10_tf);
  oled.clearBuffer();
  oled.drawStr(0, 15, "Cliente conectado");
  oled.sendBuffer();

  // lcd.init(); lcd.backlight(); lcd.print("Conectado a WiFi");
}
```

#### `loop()`

```cpp
void loop() {
  if (millis() - t0 > 5000) {
    HTTPClient http;
    http.begin(serverUrl);
    int httpCode = http.GET();

    if (httpCode == 200) {
      String payload = http.getString();
      String ultimaLinea = extraerUltimaLinea(payload);
      mostrarEnPantalla(ultimaLinea);
    }

    http.end();
    t0 = millis();
  }
}
```

#### Función auxiliar para extraer el último dato

```cpp
String extraerUltimaLinea(String html) {
  int tr = html.lastIndexOf("<tr>");
  if (tr == -1) return "Sin datos";
  int td1 = html.indexOf("<td>", tr);
  int td2 = html.indexOf("</td>", td1);
  int td3 = html.indexOf("<td>", td2);
  int td4 = html.indexOf("</td>", td3);

  String fecha = html.substring(td1 + 4, td2);
  String mensaje = html.substring(td3 + 4, td4);
  return mensaje;
}
```

#### Función para mostrar en pantalla

```cpp
void mostrarEnPantalla(String mensaje) {
  oled.clearBuffer();
  oled.drawStr(0, 15, "Ultimo dato:");
  oled.drawStr(0, 30, mensaje.c_str());
  oled.sendBuffer();

  // lcd.clear(); lcd.setCursor(0, 0); lcd.print("Ultimo dato:");
  // lcd.setCursor(0, 1); lcd.print(mensaje);
}
```

---

### Actividad de comprobación

1. Conectar el ESP32 cliente a la red WiFi.
2. Verificar que la pantalla muestre correctamente el último dato recibido en el servidor.
3. Abrir un navegador en un celular o laptop conectado a la misma red y acceder a:
   `http://<IP_del_servidor>:5000`
4. Comparar la información mostrada en el ESP32 y en el navegador.
5. Verificar que el cliente funciona de forma autónoma con alimentación por batería.




