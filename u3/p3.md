# **Pr√°ctica 3 ‚Äî Sistema distribuido multiprotocolo: monitoreo aut√≥nomo con sensores, microcontroladores interconectados y servidor en computadora**

### **Objetivo general**

Implementar un sistema distribuido biom√©dico compuesto por m√∫ltiples microcontroladores ESP32 interconectados mediante Bluetooth cl√°sico y WiFi, en conjunto con una estaci√≥n central basada en una computadora personal, con el fin de adquirir, transmitir, visualizar y consultar se√±ales fisiol√≥gicas en una red local. Cada nodo operar√° de forma aut√≥noma con alimentaci√≥n por bater√≠a, integrando sensores reales, pantallas, teclados y protocolos de comunicaci√≥n inal√°mbrica.

---

### **Descripci√≥n general del sistema**

Este proyecto busca simular una red biom√©dica distribuida en la que distintos dispositivos recolectan datos fisiol√≥gicos, los transmiten por Bluetooth a nodos intermedios, y estos a su vez reenv√≠an la informaci√≥n por WiFi hacia una estaci√≥n central que act√∫a como servidor. El sistema contempla cuatro nodos principales:

* **Nodo 1 ‚Äì Sensor biom√©dico con Bluetooth**
  Microcontrolador ESP32 con sensor f√≠sico (como el MAX30102 o LM35), encargado de adquirir datos del paciente (por ejemplo, frecuencia cardiaca o temperatura) y transmitirlos peri√≥dicamente v√≠a Bluetooth cl√°sico. El nodo opera de manera aut√≥noma, mostrando los datos localmente en pantalla OLED o LCD.

* **Nodo 2 ‚Äì Puente Bluetooth/WiFi**
  Microcontrolador ESP32 encargado de recibir los datos v√≠a Bluetooth desde el Nodo 1 y reenviarlos mediante WiFi hacia un servidor central. Este nodo integra un teclado matricial para la gesti√≥n de pacientes o identificaci√≥n, y una pantalla para visualizaci√≥n de datos o estado de conexi√≥n.

* **Nodo 3 ‚Äì Servidor en computadora**
  Estaci√≥n central basada en PC (con software en Python o Node.js), encargada de recibir los datos por WiFi desde el Nodo 2, visualizarlos en consola o navegador web, y opcionalmente almacenarlos en una base de datos o archivo local.

* **Nodo 4 ‚Äì Cliente remoto**
  Puede ser un ESP32 adicional o un navegador en un celular o computadora que consulta el servidor para acceder a los datos recibidos. Este nodo act√∫a como herramienta de visualizaci√≥n externa o port√°til.

---

### **Tecnolog√≠as involucradas**

* **Bluetooth cl√°sico (SPP)** para comunicaci√≥n local entre nodos ESP32.
* **WiFi (modo cliente/estaci√≥n)** para env√≠o de datos hacia el servidor.
* **HTTP o WebSocket** como protocolo de red para la comunicaci√≥n con la PC.
* **Pantallas OLED o LCD** para mostrar lecturas o informaci√≥n del sistema.
* **Teclado matricial 4x4** para navegaci√≥n, entrada de identificadores o selecci√≥n de nodos.
* **Sensores biom√©dicos reales**, como el MAX30102 o el LM35.
* **Servidor en PC** capaz de recibir y mostrar datos en tiempo real.

---

### üë• **Distribuci√≥n por equipos**

La pr√°ctica se desarrollar√° en equipos de cuatro integrantes. Cada persona ser√° responsable de uno de los nodos descritos anteriormente. El √©xito del sistema depende de la correcta colaboraci√≥n e integraci√≥n de los m√≥dulos desarrollados por cada miembro del equipo.

## Bloque 1 ‚Äì Nodo 1: Adquisici√≥n de se√±al biom√©dica y transmisi√≥n por Bluetooth cl√°sico

### Objetivo del bloque

Configurar un microcontrolador ESP32 que funcione como nodo de adquisici√≥n biom√©dica, capturando se√±ales fisiol√≥gicas mediante un sensor digital o anal√≥gico (como el MAX30102 o el LM35), visualizando los datos localmente en una pantalla OLED o LCD, y transmiti√©ndolos de forma inal√°mbrica por Bluetooth cl√°sico (SPP) hacia el nodo intermedio.

---

### Introducci√≥n te√≥rica

Los microcontroladores ESP32 permiten integrar sensores biom√©dicos tanto digitales como anal√≥gicos, y pueden enviar los datos adquiridos a otros dispositivos mediante Bluetooth cl√°sico. Este tipo de comunicaci√≥n inal√°mbrica es adecuada para enlaces de corto alcance y bajo consumo, como los que se presentan entre dispositivos corporales o port√°tiles.

En este bloque, cada alumno implementar√° un nodo aut√≥nomo que funciona como unidad de captura de se√±ales, alimentado por bater√≠a, y capaz de mostrar localmente las lecturas y enviarlas por Bluetooth.

---

### Material necesario

* ESP32 con soporte para Bluetooth cl√°sico.
* Sensor biom√©dico:

  * Sensor digital (por ejemplo, MAX30102).
  * Sensor anal√≥gico (por ejemplo, LM35, TMP36, etc.).
* Pantalla:

  * OLED 128x32 o 128x64 (I2C).
  * LCD 16x2 con m√≥dulo I2C.
* Cables y protoboard.
* Bater√≠a USB o banco de energ√≠a.

---

### C√≥digo base ‚Äì Versi√≥n con sensor anal√≥gico (ej. LM35)

A continuaci√≥n se presenta el c√≥digo base para un sensor anal√≥gico y dos versiones de pantalla: OLED y LCD. El alumno debe elegir una seg√∫n el componente disponible.

#### Configuraci√≥n com√∫n

```cpp
#include <BluetoothSerial.h>
BluetoothSerial SerialBT;

const int pinSensor = 34;  // Entrada anal√≥gica
float temperatura = 0;
unsigned long t0 = 0;
```

#### Versi√≥n con OLED (128x32 o 128x64)

```cpp
#include <Wire.h>
#include <U8g2lib.h>

// Descomentar seg√∫n el modelo de pantalla:
// U8G2_SSD1306_128X64_NONAME_F_HW_I2C display(U8G2_R0, U8X8_PIN_NONE);
U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C display(U8G2_R0, U8X8_PIN_NONE);

void setup() {
  SerialBT.begin("Nodo1_Bluetooth");  // Nombre Bluetooth visible
  display.begin();
  display.clearBuffer();
  display.setFont(u8g2_font_6x10_tf);
}

void loop() {
  if (millis() - t0 > 2000) {
    int valorADC = analogRead(pinSensor);
    temperatura = (valorADC * 3.3 / 4095.0) * 100;  // Para LM35: 10 mV/¬∞C

    String mensaje = "Temp:" + String(temperatura, 1) + " C";
    SerialBT.println(mensaje);

    display.clearBuffer();
    display.drawStr(0, 15, "Sensor: LM35");
    display.drawStr(0, 30, mensaje.c_str());
    display.sendBuffer();

    t0 = millis();
  }
}
```

#### Versi√≥n con LCD 16x2 (I2C)

```cpp
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x27, 16, 2);  // Ajustar direcci√≥n si es necesario

void setup() {
  SerialBT.begin("Nodo1_Bluetooth");
  lcd.init();
  lcd.backlight();
}

void loop() {
  if (millis() - t0 > 2000) {
    int valorADC = analogRead(pinSensor);
    temperatura = (valorADC * 3.3 / 4095.0) * 100;

    String mensaje = "Temp:" + String(temperatura, 1) + " C";
    SerialBT.println(mensaje);

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Sensor: LM35");
    lcd.setCursor(0, 1);
    lcd.print(mensaje);

    t0 = millis();
  }
}
```

---

### Alternativa ‚Äì C√≥digo base con sensor digital MAX30102

Para sensores digitales como el MAX30102, se requiere instalar la librer√≠a adecuada (por ejemplo, [SparkFun MAX3010x Sensor Library](https://github.com/sparkfun/SparkFun_MAX3010x_Sensor_Library)).

```cpp
#include <Wire.h>
#include <MAX30105.h>
#include <BluetoothSerial.h>
#include <U8g2lib.h>

MAX30105 particleSensor;
BluetoothSerial SerialBT;
U8G2_SSD1306_128X64_NONAME_F_HW_I2C display(U8G2_R0, U8X8_PIN_NONE);

unsigned long t0 = 0;

void setup() {
  Serial.begin(115200);
  SerialBT.begin("Nodo1_Bluetooth");
  Wire.begin();
  display.begin();
  display.setFont(u8g2_font_6x10_tf);

  if (!particleSensor.begin(Wire, I2C_SPEED_STANDARD)) {
    while (1);  // Sensor no encontrado
  }
  particleSensor.setup();  // Configuraci√≥n por defecto
}

void loop() {
  if (millis() - t0 > 2000) {
    uint32_t ir = particleSensor.getIR();

    String mensaje = "IR: " + String(ir);
    SerialBT.println(mensaje);

    display.clearBuffer();
    display.drawStr(0, 15, "Sensor: MAX30102");
    display.drawStr(0, 30, mensaje.c_str());
    display.sendBuffer();

    t0 = millis();
  }
}
```

---

### Actividad de comprobaci√≥n

1. Conectar el sensor elegido al ESP32 y verificar que las lecturas se muestren correctamente en la pantalla local.
2. Conectar el ESP32 a una bater√≠a externa y validar su funcionamiento aut√≥nomo.
3. Verificar, desde el monitor serial de una PC o desde otro dispositivo con Bluetooth, que los datos se est√°n transmitiendo correctamente.
4. Hacer capturas o video de funcionamiento para validaci√≥n del equipo docente.


## Bloque 2 ‚Äì Nodo 2: Receptor Bluetooth y transmisor WiFi con pantalla y teclado

### Objetivo del bloque

Implementar un nodo intermedio que reciba datos biom√©dicos por Bluetooth desde un nodo sensor, los visualice en una pantalla local (OLED o LCD), permita la interacci√≥n del usuario mediante un teclado matricial 4x4, y reenv√≠e los datos por WiFi a un servidor en una computadora. Este nodo tambi√©n opera de forma aut√≥noma con alimentaci√≥n por bater√≠a.

---

### Introducci√≥n te√≥rica

El uso de un nodo intermedio como puente entre tecnolog√≠as de corto y mediano alcance (Bluetooth y WiFi) permite separar funciones en un sistema distribuido. En esta pr√°ctica, el nodo 2 recibe datos por Bluetooth cl√°sico (SPP), los asocia con una entrada local (como un ID de paciente ingresado por teclado), y los transmite por WiFi mediante una solicitud HTTP POST al servidor ubicado en una computadora de la red local.

Este nodo tambi√©n brinda retroalimentaci√≥n visual de todo el proceso mediante una pantalla, que permite confirmar la conexi√≥n, visualizar los datos recibidos y mostrar mensajes de estado.

---

### Material necesario

* ESP32 con soporte para Bluetooth y WiFi.
* Pantalla OLED 128x32 o 128x64, o LCD 16x2 con I2C.
* Teclado matricial 4x4.
* Resistencias tipo pull-down o m√≥dulo teclado con pines comunes.
* Cables, protoboard y bater√≠a.

---

### C√≥digo base ‚Äì Recepci√≥n Bluetooth, entrada por teclado y reenv√≠o por WiFi

#### Librer√≠as requeridas

```cpp
#include <BluetoothSerial.h>
#include <WiFi.h>
#include <Wire.h>
#include <Keypad.h>
#include <LiquidCrystal_I2C.h>           // Para LCD
#include <U8g2lib.h>                     // Para OLED
#include <HTTPClient.h>
```

#### Configuraci√≥n de perif√©ricos

```cpp
// Bluetooth
BluetoothSerial SerialBT;

// WiFi
const char* ssid = "TuSSID";
const char* password = "TuPassword";
const char* serverUrl = "http://192.168.1.100:5000/datos"; // Cambiar IP/puerto seg√∫n servidor

// Pantalla (elige una)
U8G2_SSD1306_128X64_NONAME_F_HW_I2C oled(U8G2_R0, U8X8_PIN_NONE);
// LiquidCrystal_I2C lcd(0x27, 16, 2);  // Descomentar si se usa LCD

// Teclado
const byte ROWS = 4; 
const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {19, 18, 5, 17};
byte colPins[COLS] = {16, 4, 2, 15};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

// Variables
String bufferBluetooth = "";
String idPaciente = "0000";
unsigned long t0 = 0;
```

#### `setup()`

```cpp
void setup() {
  Serial.begin(115200);
  SerialBT.begin("Nodo2_Bridge");
  
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
  }

  oled.begin();
  oled.setFont(u8g2_font_6x10_tf);
  oled.clearBuffer();
  oled.drawStr(0, 15, "Nodo 2 listo.");
  oled.sendBuffer();

  // lcd.init(); lcd.backlight();  // Descomentar si se usa LCD
}
```

#### `loop()`

```cpp
void loop() {
  // Leer teclado
  char key = keypad.getKey();
  if (key && key >= '0' && key <= '9') {
    idPaciente += key;
    if (idPaciente.length() > 4) idPaciente = idPaciente.substring(idPaciente.length()-4);
  }

  // Leer Bluetooth
  while (SerialBT.available()) {
    char c = SerialBT.read();
    if (c == '\n') {
      String mensaje = "ID:" + idPaciente + "," + bufferBluetooth;
      enviarWiFi(mensaje);
      mostrarEnPantalla(mensaje);
      bufferBluetooth = "";
    } else {
      bufferBluetooth += c;
    }
  }
}
```

#### Funci√≥n para enviar datos por WiFi

```cpp
void enviarWiFi(String datos) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin(serverUrl);
    http.addHeader("Content-Type", "application/x-www-form-urlencoded");
    String body = "mensaje=" + datos;
    http.POST(body);
    http.end();
  }
}
```

#### Funci√≥n para mostrar en pantalla

```cpp
void mostrarEnPantalla(String texto) {
  oled.clearBuffer();
  oled.drawStr(0, 15, "Enviado:");
  oled.drawStr(0, 30, texto.c_str());
  oled.sendBuffer();

  // lcd.clear(); lcd.setCursor(0, 0); lcd.print("Enviado:");
  // lcd.setCursor(0, 1); lcd.print(texto);  // Para LCD
}
```

---

### Actividad de comprobaci√≥n

1. Verificar que el nodo reciba correctamente los datos enviados por Bluetooth desde el Nodo 1.
2. Ingresar una secuencia de n√∫meros en el teclado (ID del paciente) y observar que se adjunta al mensaje.
3. Confirmar en el servidor que los datos est√°n llegando por WiFi.
4. Validar que los datos se muestren en la pantalla del nodo de forma clara.
5. Probar el funcionamiento completo con bater√≠a y sin conexi√≥n a la computadora.


