## **Práctica 1. Comunicación Bluetooth clásica con ESP32 y periféricos interactivos**

---

### **Objetivo general**

Implementar una comunicación bidireccional mediante Bluetooth clásico (Serial Port Profile) entre dispositivos ESP32, y entre un ESP32 y un dispositivo externo (PC o celular), integrando un sistema interactivo compuesto por teclado matricial 4x4, pantalla OLED o LCD y botones físicos, todo funcionando de forma autónoma sin conexión a computadora, con alimentación independiente por batería USB.

---

### **1. Introducción teórica**

La comunicación Bluetooth clásica permite el intercambio de datos entre dispositivos de forma inalámbrica, utilizando el perfil **Serial Port Profile (SPP)**, que emula un canal UART para transmitir bytes de manera sencilla.

El microcontrolador **ESP32** incluye soporte nativo para Bluetooth clásico y BLE. En esta práctica se usará la biblioteca `BluetoothSerial.h` del entorno de Arduino para establecer enlaces punto a punto (maestro ↔ esclavo), así como conexiones con dispositivos externos como computadoras o teléfonos inteligentes.

El sistema incluirá los siguientes periféricos:

* **Pantalla**: puede ser un OLED 128x32 u 128x64 por I2C, o una LCD 16x2 con convertidor I2C. Estas permiten mostrar información de estado, datos recibidos o menús interactivos.
* **Teclado matricial 4x4**: sirve como interfaz de entrada para enviar comandos o seleccionar opciones.
* **Botones físicos**: pueden utilizarse para tareas como reconexión manual, selección de modo o interacción rápida.
* **Alimentación por batería USB**: permitirá que cada ESP32 funcione de forma completamente autónoma.

La práctica incluye tres modalidades principales:

1. **ESP32 ↔ ESP32**: comunicación directa entre dos microcontroladores.
2. **ESP32 ↔ PC/Celular**: enlace con Python (PC) o apps de terminal Bluetooth (Android/iOS).
3. **ESP32 ↔ múltiples ESP32**: selección dinámica de dispositivos destino desde el teclado.

Además, se busca que todos los dispositivos funcionen sin necesidad de estar conectados por USB a la computadora durante su operación.

---

Perfecto. A continuación se presenta el **primer bloque funcional** del desarrollo de la práctica, siguiendo el formato formal y detallado, en tercera persona, como en las prácticas anteriores del curso de Microcontroladores.

---

## **Bloque 1. Comunicación Bluetooth clásica entre dos ESP32 (maestro ↔ esclavo)**

### **Objetivo del bloque**

Establecer una comunicación Bluetooth punto a punto entre dos ESP32 utilizando el perfil Serial Port Profile (SPP), donde uno actúe como maestro y otro como esclavo. Se visualizará el estado de conexión y los datos intercambiados en pantalla, y se validará el funcionamiento autónomo sin computadora.

---

### **1.1. Fundamento técnico**

El perfil SPP permite simular una comunicación serial UART a través de una conexión Bluetooth. Esto es útil para establecer enlaces entre dispositivos sin necesidad de cables, manteniendo una interfaz sencilla basada en el intercambio de caracteres o cadenas de texto.

El ESP32 permite operar como dispositivo maestro o esclavo mediante la biblioteca `BluetoothSerial`. En este bloque, uno de los ESP32 actuará como maestro, intentando conectarse al otro dispositivo (esclavo) mediante su dirección MAC.

Se recomienda utilizar la dirección MAC para la conexión en lugar del nombre, ya que la conexión por nombre es poco confiable en algunas versiones del firmware del ESP32.

---

### **1.2. Configuración del ESP32 esclavo**

El alumno debe cargar el siguiente código en el ESP32 que operará como **esclavo**. Este ESP32 esperará una conexión entrante y mostrará su dirección MAC por el monitor serial para que pueda ser utilizada por el maestro.

```cpp
#include "BluetoothSerial.h"
#include "esp_bt_device.h"

BluetoothSerial SerialBT;

void setup() {
  Serial.begin(115200);

  // Iniciar Bluetooth como esclavo con nombre identificable
  SerialBT.begin("ESP32-BT-Slave");

  // Obtener y mostrar la dirección MAC del dispositivo
  const uint8_t* mac = esp_bt_dev_get_address();
  char macStr[18];
  sprintf(macStr, "%02X:%02X:%02X:%02X:%02X:%02X",
          mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  Serial.println("Esperando conexión Bluetooth...");
  Serial.print("Dirección MAC del esclavo: ");
  Serial.println(macStr);
}

void loop() {
  // Si hay datos entrantes por Bluetooth, se envían al monitor serial
  if (SerialBT.available()) {
    char c = SerialBT.read();
    Serial.write(c);
  }

  // Si hay datos por USB, se envían al Bluetooth (debug opcional)
  if (Serial.available()) {
    SerialBT.write(Serial.read());
  }
}
```

---

### **1.3. Configuración del ESP32 maestro**

El alumno debe cargar el siguiente código en el ESP32 que actuará como **maestro**. Este dispositivo intentará conectarse automáticamente al esclavo usando su dirección MAC.

> ⚠️ **Nota:** Se debe reemplazar la dirección MAC en el arreglo `address[6]` con la obtenida desde el ESP32 esclavo en la sección anterior.

```cpp
#include "BluetoothSerial.h"

BluetoothSerial SerialBT;

// Dirección MAC del esclavo (reemplazar con la obtenida previamente)
uint8_t address[6] = { 0xAC, 0x67, 0xB2, 0x2D, 0x21, 0x2A }; 

void setup() {
  Serial.begin(115200);

  // Iniciar Bluetooth como maestro
  SerialBT.begin("ESP32-BT-Master", true);  // true → modo maestro
  Serial.println("Intentando conectar al esclavo...");

  // Intentar conexión
  if (SerialBT.connect(address)) {
    Serial.println("¡Conectado exitosamente al esclavo!");
  } else {
    Serial.println("No se pudo establecer conexión.");
  }
}

void loop() {
  // Redirección UART → Bluetooth
  if (Serial.available()) {
    SerialBT.write(Serial.read());
  }

  // Redirección Bluetooth → UART
  if (SerialBT.available()) {
    Serial.write(SerialBT.read());
  }
}
```

---

### **1.4. Validación del funcionamiento**

Una vez cargados los códigos:

1. Se energizan ambos ESP32 (pueden estar conectados a la PC o a una batería USB).
2. En el monitor serial del esclavo aparecerá su dirección MAC.
3. El maestro debe establecer conexión automática y mostrar el mensaje de éxito.
4. Al escribir texto en el monitor serial del maestro, este debe ser recibido y mostrado por el esclavo (y viceversa).

---

## **Bloque 2. Interfaz con teclado 4x4 para envío de comandos Bluetooth**

### **Objetivo del bloque**

Incorporar un teclado matricial 4x4 al ESP32 maestro para permitir el envío de comandos personalizados al ESP32 esclavo a través de Bluetooth clásico. Cada tecla se mapeará a una acción o mensaje definido. Se utilizará la librería `Keypad.h` para facilitar la lectura de teclas.

---

### **2.1. Fundamento técnico**

Un teclado matricial 4x4 está compuesto por 16 teclas organizadas en 4 filas y 4 columnas. Al presionar una tecla, se produce un corto entre una fila y una columna. Para detectar la tecla presionada, se escanean las filas y columnas mediante pines digitales del microcontrolador.

La librería `Keypad.h` permite gestionar esta matriz de forma sencilla y confiable, mediante el uso de dos arreglos que definen la disposición lógica y los pines físicos conectados.

En este bloque, el teclado estará conectado al ESP32 maestro. Cada tecla generará un carácter que será transmitido mediante `SerialBT.write()` hacia el esclavo, quien posteriormente lo podrá visualizar o interpretar como comando.

---

### **2.2. Conexión física del teclado**

El teclado debe conectarse a 8 pines digitales disponibles del ESP32 maestro. La asignación sugerida es:

| Fila/Columna | Pin ESP32 sugerido |
| ------------ | ------------------ |
| Fila 1       | GPIO 13            |
| Fila 2       | GPIO 12            |
| Fila 3       | GPIO 14            |
| Fila 4       | GPIO 27            |
| Columna 1    | GPIO 26            |
| Columna 2    | GPIO 25            |
| Columna 3    | GPIO 33            |
| Columna 4    | GPIO 32            |

> ⚠️ **Importante:** Verificar que los pines no interfieran con otros periféricos en uso, como la pantalla o sensores.

---

### **2.3. Código del ESP32 maestro con teclado integrado**

Se debe agregar el siguiente código al maestro, combinando el módulo Bluetooth y la lectura del teclado. Este código detecta la tecla presionada y la envía inmediatamente al esclavo.

```cpp
#include <BluetoothSerial.h>
#include <Keypad.h>

BluetoothSerial SerialBT;

// Dirección MAC del esclavo
uint8_t address[6] = { 0xAC, 0x67, 0xB2, 0x2D, 0x21, 0x2A };

// Mapeo lógico del teclado
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  { '1','2','3','A' },
  { '4','5','6','B' },
  { '7','8','9','C' },
  { '*','0','#','D' }
};

// Pines conectados al teclado
byte rowPins[ROWS] = {13, 12, 14, 27};  // F1-F4
byte colPins[COLS] = {26, 25, 33, 32};  // C1-C4

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

void setup() {
  Serial.begin(115200);
  SerialBT.begin("ESP32-BT-Master", true);
  Serial.println("Iniciando conexión con esclavo...");

  if (SerialBT.connect(address)) {
    Serial.println("Conectado al esclavo.");
  } else {
    Serial.println("No se pudo conectar.");
  }
}

void loop() {
  // Leer tecla presionada
  char key = keypad.getKey();
  if (key) {
    Serial.print("Tecla presionada: ");
    Serial.println(key);
    SerialBT.write(key);  // Enviar por Bluetooth
  }

  // Leer datos entrantes (opcional)
  if (SerialBT.available()) {
    char c = SerialBT.read();
    Serial.print("Recibido: ");
    Serial.println(c);
  }
}
```

---

### **2.4. Validación**

Una vez cargado el código:

1. Presionar una tecla del teclado 4x4 en el maestro.
2. Verificar que el carácter aparece en el monitor serial del maestro.
3. Observar que el mismo carácter se recibe y muestra en el monitor serial del esclavo (o posteriormente en la pantalla del esclavo).
4. Probar múltiples teclas: letras, números y símbolos.

---

### **2.5. Comentarios adicionales**

* Se puede extender la lógica para que ciertas teclas envíen comandos más largos o desencadenen acciones especiales (ej. `'A'` = mostrar menú, `'B'` = limpiar pantalla).
* Si se desea evitar rebotes o repeticiones rápidas de teclas, puede integrarse una lógica de “antirrebote” por software o un retardo mínimo entre lecturas.

---

## **Bloque 3. Visualización en pantalla OLED o LCD de los datos recibidos**

### **Objetivo del bloque**

Incorporar una pantalla gráfica (OLED 128x32 / 128x64) o una pantalla de texto (LCD 16x2 con módulo I2C) al ESP32 esclavo, para mostrar en tiempo real los caracteres enviados desde el ESP32 maestro mediante Bluetooth clásico. Esto permite una retroalimentación visual directa sin necesidad de usar el monitor serial, facilitando la operación autónoma del sistema.

---

### **3.1. Fundamento técnico**

Las pantallas I2C permiten mostrar información con un mínimo de pines del microcontrolador (solo dos líneas: SDA y SCL), dejando libres otros pines para teclados, sensores u otros periféricos.

El ESP32 es compatible tanto con pantallas **OLED** (basadas en el controlador SSD1306 o SH1106) como con pantallas **LCD 16x2** con adaptador I2C (controlador PCF8574). En esta práctica se dará prioridad a la pantalla OLED por su flexibilidad gráfica, aunque se proporciona también una variante compatible con LCD.

Para pantallas OLED, se recomienda utilizar la librería **`U8g2`**, ya que soporta múltiples resoluciones y tipos de controladores. Para LCD se usará la librería `LiquidCrystal_I2C`.

---

### **3.2. Conexión de la pantalla al ESP32 esclavo**

La conexión es idéntica para OLED o LCD con interfaz I2C:

| Pantalla | ESP32     |
| -------- | --------- |
| VCC      | 3.3V o 5V |
| GND      | GND       |
| SDA      | GPIO 21   |
| SCL      | GPIO 22   |

> ⚠️ Asegurarse de que no haya conflictos con otros dispositivos I2C (como sensores) conectados al mismo bus.

---

### **3.3. Código del ESP32 esclavo con pantalla OLED (U8g2)**

El siguiente código muestra en pantalla los caracteres recibidos uno a uno. Se puede adaptar para mostrar texto acumulado o procesar comandos complejos si se desea.

```cpp
#include <BluetoothSerial.h>
#include <U8g2lib.h>
#include "esp_bt_device.h"

BluetoothSerial SerialBT;

// Pantalla OLED 128x64 por I2C (SSD1306)
U8G2_SSD1306_128X64_NONAME_F_HW_I2C display(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

// Variable de texto recibido
String textoRecibido = "";

void setup() {
  Serial.begin(115200);
  SerialBT.begin("ESP32-BT-Slave");

  display.begin();
  display.setFont(u8g2_font_ncenB08_tr);
  display.clearBuffer();
  display.drawStr(0, 15, "Esperando...");
  display.sendBuffer();

  // Imprimir dirección MAC
  const uint8_t* mac = esp_bt_dev_get_address();
  char macStr[18];
  sprintf(macStr, "%02X:%02X:%02X:%02X:%02X:%02X", 
          mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  Serial.print("MAC: ");
  Serial.println(macStr);
}

void loop() {
  if (SerialBT.available()) {
    char c = SerialBT.read();
    textoRecibido += c;

    // Mostrar texto en pantalla
    display.clearBuffer();
    display.drawStr(0, 15, "Recibido:");
    display.drawStr(0, 35, textoRecibido.c_str());
    display.sendBuffer();

    // Mostrar también por consola (opcional)
    Serial.print(c);

    // Limpiar si se excede del área
    if (textoRecibido.length() > 16) {
      textoRecibido = "";
    }
  }
}
```

---

### **3.4. Alternativa: Código para pantalla LCD 16x2 (I2C)**

```cpp
#include <BluetoothSerial.h>
#include <LiquidCrystal_I2C.h>
#include "esp_bt_device.h"

BluetoothSerial SerialBT;

// Pantalla LCD 16x2 por I2C
LiquidCrystal_I2C lcd(0x27, 16, 2);
String buffer = "";

void setup() {
  Serial.begin(115200);
  SerialBT.begin("ESP32-BT-Slave");

  lcd.init();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print("Esperando...");

  // Imprimir dirección MAC
  const uint8_t* mac = esp_bt_dev_get_address();
  char macStr[18];
  sprintf(macStr, "%02X:%02X:%02X:%02X:%02X:%02X", 
          mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  Serial.print("MAC: ");
  Serial.println(macStr);
}

void loop() {
  if (SerialBT.available()) {
    char c = SerialBT.read();
    buffer += c;

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Recibido:");
    lcd.setCursor(0, 1);
    lcd.print(buffer);

    Serial.print(c);

    if (buffer.length() > 16) {
      buffer = "";
    }
  }
}
```

---

### **3.5. Validación del bloque**

Una vez conectado el teclado en el maestro y la pantalla en el esclavo:

1. Presionar una tecla en el teclado 4x4 del maestro.
2. Verificar que el carácter aparece:

   * En el monitor serial del maestro.
   * En el monitor serial del esclavo (opcional).
   * En la pantalla OLED o LCD del esclavo.
3. Enviar múltiples teclas y observar la actualización dinámica del contenido.
4. Hacer los ajustes necesarios para comprobar el funcionamiento sin PC, usando una batería USB.

---


