## **PrÃ¡ctica 6: Control de LED con Estado Memorizado**

### **Objetivo de la prÃ¡ctica**

Implementar un control de LED que **cambie de estado** (encienda o apague) **cada vez que se presione un botÃ³n**, sin necesidad de mantenerlo presionado. Esta prÃ¡ctica introduce la lÃ³gica de **estado memorizado**, que se utiliza en mÃºltiples aplicaciones reales como interruptores digitales, controles remotos o pulsadores tÃ¡ctiles.

---

### **1. IntroducciÃ³n teÃ³rica**

A diferencia de un botÃ³n que activa una acciÃ³n mientras se mantiene presionado, en esta prÃ¡ctica el LED **conmutarÃ¡** su estado con cada pulsaciÃ³n. Este tipo de lÃ³gica requiere:

* Detectar **transiciones de estado** del botÃ³n (flanco de subida).
* Utilizar una **variable de estado** para guardar si el LED estÃ¡ encendido o apagado.
* Evitar falsos disparos por rebote (*debounce*).

> ðŸ’¡ Este comportamiento es tÃ­pico en interfaces humanas, como un botÃ³n de encendido que alterna entre ON y OFF.

---

### **2. Material necesario**

* Arduino Uno, Nano o ESP32.
* 1 botÃ³n.
* 1 LED.
* 2 resistencias: 220 ohms (LED) y 10k ohms (pull-down).
* Protoboard y cables.
* Computadora con el IDE de Arduino.
* Cable USB.

---

### **3. Diagrama de conexiÃ³n**

Igual que en prÃ¡cticas anteriores:

* BotÃ³n conectado al pin 2 (con pull-down).
* LED conectado al pin 13 (o cualquier otro).

---

### **4. CÃ³digo base de la prÃ¡ctica**

```cpp
const int pinBoton = 2;
const int pinLED = 13;

bool estadoLED = false;
bool estadoBotonAnterior = LOW;

unsigned long ultimaLectura = 0;
const unsigned long retardoRebote = 50;

void setup() {
  pinMode(pinBoton, INPUT);
  pinMode(pinLED, OUTPUT);
  digitalWrite(pinLED, LOW);
}

void loop() {
  bool lecturaActual = digitalRead(pinBoton);

  if (lecturaActual != estadoBotonAnterior) {
    ultimaLectura = millis(); // Se detectÃ³ un cambio
  }

  if ((millis() - ultimaLectura) > retardoRebote) {
    if (lecturaActual == HIGH && estadoBotonAnterior == LOW) {
      estadoLED = !estadoLED; // Cambia el estado del LED
      digitalWrite(pinLED, estadoLED ? HIGH : LOW);
    }
  }

  estadoBotonAnterior = lecturaActual;
}
```

---

### **5. ExplicaciÃ³n paso a paso**

#### **5.1. DetecciÃ³n de flanco de subida**

```cpp
if (lecturaActual == HIGH && estadoBotonAnterior == LOW)
```

* Esto detecta el momento exacto en que el botÃ³n **pasa de no presionado a presionado**.

#### **5.2. ConmutaciÃ³n de estado**

```cpp
estadoLED = !estadoLED;
```

* Invierte el valor lÃ³gico actual:

  * Si estÃ¡ encendido â†’ se apaga.
  * Si estÃ¡ apagado â†’ se enciende.

#### **5.3. Escritura en el pin**

```cpp
digitalWrite(pinLED, estadoLED ? HIGH : LOW);
```

* Enciende o apaga el LED segÃºn el estado guardado.

---

### **6. Ventajas del enfoque**

* El LED **no necesita mantenerse presionado**: basta una pulsaciÃ³n corta.
* Se puede expandir fÃ¡cilmente a mÃºltiples botones o salidas.
* Se entrena el uso de **variables booleanas** y la detecciÃ³n de eventos.

---

### **7. Actividad de comprobaciÃ³n**

> **Ejercicio:** Modificar el cÃ³digo para que:
>
> 1. El **LED inicie encendido**.
> 2. DespuÃ©s de **cada tercera pulsaciÃ³n** del botÃ³n, el LED **parpadee rÃ¡pidamente 5 veces** y luego **regrese a su estado anterior**.
> 3. Mostrar en el **monitor serial** cuÃ¡ntas pulsaciones lleva el usuario desde que encendiÃ³ la placa.

> **Pistas:**
>
> * Se necesita una variable entera para contar pulsaciones.
> * Puedes usar un ciclo `for` para parpadear 5 veces.
> * Usa `Serial.begin(9600);` y `Serial.println(contador);` para imprimir.

