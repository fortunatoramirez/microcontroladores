## **PrÃ¡ctica 12: Control del Brillo de un LED con un BotÃ³n (PWM + Estado Memorizado)**

### **Objetivo de la prÃ¡ctica**

Aplicar el uso de **PWM** junto con una **entrada digital (botÃ³n)** para modificar el **brillo de un LED** en pasos progresivos. Cada vez que el usuario presiona el botÃ³n, el microcontrolador incrementa el valor de brillo del LED, hasta alcanzar el mÃ¡ximo, y luego lo reinicia.

---

### **1. IntroducciÃ³n teÃ³rica**

Esta prÃ¡ctica combina dos conceptos clave:

* **PWM** (para simular distintos niveles de voltaje en un LED).
* **Estado memorizado** (para guardar el valor actual del brillo entre pulsaciones).

El valor de PWM (`analogWrite()`) se incrementarÃ¡ con cada pulsaciÃ³n del botÃ³n, en pasos definidos, y se reiniciarÃ¡ cuando alcance el mÃ¡ximo.

> ðŸ’¡ Esta lÃ³gica es comÃºn en sistemas sin interfaz compleja, como atenuadores de luz, controladores de volumen por pulsos, o ajustes cÃ­clicos.

---

### **2. Material necesario**

* Arduino Uno, Nano o ESP32.
* 1 botÃ³n.
* 1 LED.
* 2 resistencias: 220 ohms (LED) y 10k ohms (pull-down).
* Protoboard y cables.
* Computadora con el IDE de Arduino.
* Cable USB.

---

### **3. Diagrama de conexiÃ³n**

* BotÃ³n conectado al pin 2 (con pull-down de 10k).
* LED conectado al pin 9 (PWM) con resistencia de 220 ohms.

---

### **4. CÃ³digo base de la prÃ¡ctica**

```cpp
const int pinBoton = 2;
const int pinLED = 9;

int brillo = 0;
const int paso = 51; // Brillo aumenta en 20% cada vez (255 / 5 â‰ˆ 51)
bool estadoAnterior = LOW;
unsigned long tiempoUltimoCambio = 0;
const unsigned long debounce = 50;

void setup() {
  pinMode(pinBoton, INPUT);
  pinMode(pinLED, OUTPUT);
  Serial.begin(9600);
}

void loop() {
  bool estadoActual = digitalRead(pinBoton);

  if (estadoActual != estadoAnterior) {
    tiempoUltimoCambio = millis();
  }

  if ((millis() - tiempoUltimoCambio) > debounce) {
    if (estadoActual == HIGH && estadoAnterior == LOW) {
      brillo += paso;
      if (brillo > 255) {
        brillo = 0; // Reinicia al llegar al mÃ¡ximo
      }
      analogWrite(pinLED, brillo);

      // Mostrar porcentaje en monitor serial
      int porcentaje = map(brillo, 0, 255, 0, 100);
      Serial.print("Brillo: ");
      Serial.print(porcentaje);
      Serial.println("%");
    }
  }

  estadoAnterior = estadoActual;
}
```

---

### **5. ExplicaciÃ³n paso a paso**

#### **5.1. Variable `brillo`**

* Guarda el nivel actual de brillo (0 a 255).
* Se incrementa en pasos definidos (`paso = 51` â†’ 20%).

#### **5.2. LÃ³gica de avance por botÃ³n**

```cpp
if (estadoActual == HIGH && estadoAnterior == LOW)
```

* Detecta flanco de subida (cuando se presiona el botÃ³n).
* Cambia el valor del brillo sin necesidad de mantener el botÃ³n presionado.

#### **5.3. Reinicio de ciclo**

```cpp
if (brillo > 255) {
  brillo = 0;
}
```

* Una vez alcanzado el valor mÃ¡ximo, el brillo vuelve a 0.

#### **5.4. VisualizaciÃ³n serial**

```cpp
int porcentaje = map(brillo, 0, 255, 0, 100);
```

* Convierte el valor de 0 a 255 en porcentaje (0% a 100%).

---

### **6. Aplicaciones reales del patrÃ³n**

* Control por botÃ³n Ãºnico en **lamparas regulables**.
* Ajuste cÃ­clico de **intensidad sonora**.
* Interfaces sin pantallas ni menÃºs.

---

### **7. Actividad de comprobaciÃ³n**

> **Ejercicio:** Modificar el cÃ³digo para que:
>
> 1. El **brillo aumente cada vez que se presione el botÃ³n** hasta 100%, y luego comience a **disminuir en los mismos pasos** hasta llegar a 0%, y repita el ciclo.
> 2. Mostrar en el monitor serial si el brillo estÃ¡ **"Aumentando"** o **"Disminuyendo"** en cada paso.
> 3. Agregar una pausa visual de **1 segundo** cuando se alcanza el brillo mÃ¡ximo o mÃ­nimo, para indicar el cambio de direcciÃ³n.

> **Pistas:**
>
> * Puedes usar una variable `subiendo` tipo `bool` que indique la direcciÃ³n actual.
> * Usar `delay(1000);` al alcanzar `brillo == 255` o `brillo == 0`.
